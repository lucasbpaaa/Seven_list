#Question 1:

def find_judge(n, trust):
    if n == 1:
        return 1 #Se só há uma pessoa, ela é automaticamnte juiz.
    
    confia = [0]*(n+1)
    confiado = [0]*(n+1)
    for ai, bi in trust:
        confia[ai] += 1
        confiado[bi] += 1

    for i in range(1, n + 1):
        if confia[i] == 0 and confiado[i] == n - 1:
            return i
    return -1



''''

Exemplo, caso queira:
n = 4
trust = [[ 1 , 3 ], [ 2 , 3 ], [ 3 , 1 ], [3, 4], [1, 4], [2, 4]]
print(find_judge(n, trust)) 

'''

#Question 2:

#Item a:

import math

def euclidean_distance(p1, p2):
    return math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)

# Função para encontrar o representante de um conjunto no Union-Find
def find(parent, i):
    if parent[i] == i:
        return i
    else:
        parent[i] = find(parent, parent[i])  # Path compression
        return parent[i]

# Função para unir dois conjuntos no Union-Find
def union(parent, rank, x, y):
    rootX = find(parent, x)
    rootY = find(parent, y)
    
    if rootX != rootY:
        if rank[rootX] > rank[rootY]:
            parent[rootY] = rootX
        elif rank[rootX] < rank[rootY]:
            parent[rootX] = rootY
        else:
            parent[rootY] = rootX
            rank[rootX] += 1

# Algoritmo de Kruskal para encontrar a Árvore Geradora Mínima (MST)
def kruskal(vertices):
    n = len(vertices)
    edges = []
    
    # Calculando todas as arestas com as respectivas distâncias
    for i in range(n):
        for j in range(i + 1, n):
            distance = euclidean_distance(vertices[i], vertices[j])
            edges.append((distance, i, j))  # (peso, vértice1, vértice2)
    
    # Ordenando as arestas pela distância
    edges.sort()
    
    # Inicializando a estrutura Union-Find
    parent = list(range(n))
    rank = [0] * n
    
    mst = []  # Lista de arestas que formarão a MST
    mst_cost = 0  # Custo total da MST
    
    # Iterando sobre as arestas, e unindo os conjuntos disjuntos
    for weight, u, v in edges:
        root_u = find(parent, u)
        root_v = find(parent, v)
        
        # Se u e v não estão no mesmo conjunto, unimos e adicionamos a aresta na MST
        if root_u != root_v:
            mst.append((u, v, weight))
            mst_cost += weight
            union(parent, rank, root_u, root_v)
    
    return mst_cost, mst

''''

Exemplo, caso queira:
vertices = [(0, 0), (1, 2), (4, 3), (5, 1), (2, 5)]  # Vértices no plano (x, y)

# Encontrando a Árvore Geradora Mínima (MST)
mst_cost, mst = kruskal(vertices)

print(f"Custo total da MST: {mst_cost}")
print("Arestas da MST (vértices conectados e distâncias):")
for u, v, weight in mst:
    print(f"Vértice {u} - Vértice {v} com distância {weight:.2f}")
'''

#Item b:
''''
    A complexidade mínima de qualquer algoritmo que resolve o problema de Árvore Geradora Mínima (MST) é Ω(nlog n), pois, em um grafo com 
n vértices, o algoritmo precisa, no mínimo, realizar operações que envolvem as distâncias entre os vértices. 
No pior caso, ao selecionar as arestas de menor peso, um algoritmo eficiente como o de Prim (que utiliza uma fila de prioridade)
ou Kruskal (que ordena as arestas) precisa manipular informações para cada vértice e aresta.
    No caso de Prim, por exemplo, é necessário extrair o vértice de menor peso da fila de prioridade, o que tem complexidade 
O(logn) por operação, e isso ocorre para cada um dos n vértices. Por isso,
a complexidade mínima de um algoritmo para MST, independentemente do número de arestas, é Ω(nlog n), 
já que é necessário, pelo menos, processar cada vértice em tempo logarítmico para garantir a formação da árvore geradora mínima.
'''

#Item c:
''''
O algoritmo acima não é tão conveniente para todo tipo de grafo, como os esparsos. Concluímos que o algoritmo não é
ótimo para todo caso.
'''

#Question 3:

#Question 3:

import copy

''''
    Para n+1 pontos, temos um único polinômio de grau n que aproxima bem uma curva que passa pelos pontos. Esse 
polinômio é o interpolador de lagrange. Usaremos ele.

'''

def lagrange(T_fT, alvo, invert=False):  
    
    # Carregaremos invert, que caso for True => que queremos a relação altura x grau
    sum = 0

    T_fT = copy.deepcopy(T_fT)
    if invert:
        for T in T_fT:
            T[0], T[1] = T[1], T[0]

    for T in T_fT:
        a = 1
        for T2 in T_fT:
            if T != T2:
                a *= (alvo - T2[0]) / (T[0] - T2[0])

        sum += a * T[1]

    return sum

''''
Use, caso queira:

T_fT = ([15, 200], [9, 400], [5, 600], [3, 800], [-2, 1000], [-5, 1200], [-15, 1400])

print(f'A altura do avião a 0 graus Celsius é: {lagrange(T_fT, 0)}')
print(f'A temperatura do avião a 700 metros é: {lagrange(T_fT, 700, True)}')
'''

